import jwt from "jsonwebtoken"
export const verifyToken = (req, res, next) =>{
    try{
        // While sending token from front-end we have attached it to the request headers with a property name "authorization"
        // As it was a Bearer token it looks like a string e.g. "Bearer ourpassedToken"
        // So first we are converting this String into an Array according to the space between Bearer word and our Token
        // After converting the string into an Array we are accessing the second Element of that Array which is the Token that we recieved from front-end

        const token = req.headers.authorization?.split(" ")[1]

        // If no token was attached to the request headers we will not allow user to access private routes
        if(!token) return  res.status(401).json({message: "Not Authorized"})

        // At this point we are using two methods of jwt 
        // - decode method = that will be used to decode an O-Auth Token( here Google token) and it normally consists on more than 500 characters
        // - sign method = to verify the token and to get payload. But this method will be used to verify token that was generated by us.
        
        const payLoad = token.length > 500 ? jwt.decode(token) : jwt.verify(token,process.env.JWT_SECRET )

        if(payLoad) {
            // after verifying the token we will get the payload back from the decode / sign method
            // this payload will be the same that we passed while generating a token after Authentication
            // While generating token we provided Email address of the user in the payload
            // In this line we are attaching that email address to req Object so it could be accessible in Controller function

            req.userEmail = payLoad.email
            // We will call next only when if token is verified to give control to the controller function
            next()
        }

        // if token is not valid we will simply sent a bad request response back to user
        else res.status(401).json({message: "Not Authorized"})
    }catch(err){
        res.status(402).json({message: err.message})
    }
}